# Problem: 733. Flood Fill

def flood_fill(image, sr, sc, color):
    rows, cols = len(image), len(image[0])
    target = image[sr][sc]
    path = set()

    def dfs(r, c):
        if r < 0 or c < 0 or r == rows or c == cols or (r, c) in path or image[r][c] != target:
            return
        image[r][c] = color
        path.add((r, c))
        return (dfs(r + 1, c),
                dfs(r - 1, c),
                dfs(r, c + 1),
                dfs(r, c - 1))

    dfs(sr, sc)

    return image


answer = flood_fill(image=[[1, 1, 1], [1, 1, 0], [1, 0, 1]], sr=1, sc=1, color=2)
print(answer)


"""
В строке 4 мы получаем количество строк и столбцов списка image. Затем в 5 строке мы получаем цвет, который должны 
изменить на цвет из переменной color, и сохраняем его в переменной target. Мы также создаем множество path, чтобы 
отслеживать уже проверенные элементы списка.

В функции dfs(), базовый случай срабатывает, если r или c находятся за границами списка, если r и c уже были проверены 
(то есть находятся в множестве path), либо если элемент списка не равен цвету, который мы должны перекрасить. В 
противном случае, если базовый случай не сработал, мы перекрашиваем элемент в другой цвет, изменяем его значение, 
добавляем его в множество path и проверяем, есть ли ещё элементы того же цвета в любой из 4 сторон. Если есть, мы 
вызываем эту функцию рекурсивно, пока больше не останется элементов такого же цвета.
"""
