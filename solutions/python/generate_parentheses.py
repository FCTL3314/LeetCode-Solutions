# Problem: 22. Generate Parentheses


def generate_parenthesis(n):
    res = []

    def backtracking(cur, open_n=0, closed_n=0):
        # Базовый случай при котором комбинация скобок валидна.
        if open_n == closed_n == n:
            res.append(''.join(cur))
            return
        # Если кол-во открытых скобок < скобок, то добавляем открытую скобку.
        if open_n < n:
            cur.append('(')
            # Вызываем рекурсивно функцию, передавая кол-во открытых скобок + 1.
            backtracking(cur, open_n + 1, closed_n)
            # Если в функции выше сработал базовый случай, то она возвращается, а мы убираем последнюю скобку из cur.
            cur.pop()

        # Этот блок начнёт выполняться только тогда, когда кол-во открытых скобок будет равно n.
        if closed_n < open_n:
            cur.append(')')
            # Вызывает рекурсивную функцию, передав кол-во закрытых скобок + 1.
            backtracking(cur, open_n, closed_n + 1)
            # Если в функции выше сработал успешный случай, то она возвращается, а мы убираем последнюю скобку из cur.
            cur.pop()

    backtracking(list())

    return res


answer = generate_parenthesis(3)
print(answer)

"""
Алгоритм работает следующим образом:

1. Если количество открытых и закрытых скобок равно заданному n, то текущая комбинация является правильной и добавляется 
в список res.
2. Если количество открытых скобок меньше n, то добавляем открывающую скобку в текущую комбинацию и вызываем функцию 
backtracking рекурсивно с количеством открытых скобок увеличенным на 1.
3. Если количество открытых скобок равно n, то добавляем закрывающую скобку в текущую комбинацию и вызываем функцию 
backtracking рекурсивно с количеством закрытых скобок увеличенным на 1.
4. Если текущая комбинация является правильной скобочной последовательностью, то функция возвращает текущую комбинацию и 
убирает последнюю скобку из нее что позволяет создать новую комбинацию.
"""
